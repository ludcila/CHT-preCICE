DEBUT(PAR_LOT='NON');

from subprocess import call
import sys
sys.path.insert(0, "/home/lcheung/Thesis/CHT-preCICE/solvers/Code_Aster")
from adapter import *

# Get participant name from environment variable
# Note: In OpenFOAM and CalculiX, this is read from a command line argument (--precice-participant),
#       but I don't know how to pass my own argument to as_run
participantName = os.environ["PRECICE_PARTICIPANT"]

# ==========================================================================================
# Include file in UNITE 90: PreCICE setup (config.comm)
# Note: config.comm creates a variable named "settings", which contains the same data
#       as the config.yml file; ideally, all participants should read the same .yml file,
#       but for some reason, calling "import yaml" inside the current file causes an
#       floating point exception in Code_Aster, and therefore the .yml file cannot be read!
# ==========================================================================================

# Defines: preciceConfigFile, interfaces, participantName
INCLUDE(UNITE=90)
precice = PySolverInterface(participantName, 0, 1)
preciceConfigFile = settings["base-path"] + "/" + settings["precice-config-file"]
precice.configure(preciceConfigFile)

participant = settings["participants"][participantName]
isSteadyState = ("steady-state" in settings["simulation"]) and (settings["simulation"]["steady-state"])

# ==========================================================================================
# Include file in UNITE 91: Setup Aster case
# ==========================================================================================

# Defines: MESH, MODEL, BC[], MAT[], MATS
INCLUDE(UNITE=91)
                         
# ==========================================================================================
# Get interface mesh
# ==========================================================================================

adapter = Adapter(precice, participantName, participant["interfaces"], MESH, MODEL, MAT,
                  isNonLinear=participant["non-linear"])
BCs = [{'CHARGE': bc} for bc in BC]
LOADS = BCs + adapter.LOADS

# ==========================================================================================
# Setup preCICE
# ==========================================================================================

preciceDt = precice.initialize()

if precice.isActionRequired(PyActionWriteInitialData()):
    adapter.sendCouplingData(INIT_T, preciceDt)
    precice.fulfilledAction(PyActionWriteInitialData())

precice.initializeData()

# ==========================================================================================
# ==========================================================================================
#                                         SOLUTION LOOP
# ==========================================================================================
# ==========================================================================================

k = 0
time = 0.0

while precice.isCouplingOngoing():

    # ======================================================================================
    # Write checkpoint if necessary
    # ======================================================================================
    
    if precice.isActionRequired(PyActionWriteIterationCheckpoint()):
        if time == 0:
            ICOND = {'CHAM_NO': INIT_T}
        else:
            ICOND = {'EVOL_THER': PRV_TEMP}
        precice.fulfilledAction(PyActionWriteIterationCheckpoint())
    
    # ======================================================================================
    # Read and set boundary conditions
    # ======================================================================================
    
    adapter.receiveCouplingData()
    
    # ======================================================================================
    # Solve
    # ======================================================================================
    
    if isSteadyState:
        
        if participant["non-linear"]:
            TEMP = THER_NON_LINE(
                MODELE=MODEL,
                CHAM_MATER=MATS,
                EXCIT=LOADS,
                ETAT_INIT=_F(STATIONNAIRE='OUI'),
            )
        else:
            TEMP = THER_LINEAIRE(
                MODELE=MODEL,
                CHAM_MATER=MATS,
                EXCIT=LOADS,
                ETAT_INIT=_F(STATIONNAIRE='OUI'),
            )
            
        T = CREA_CHAMP(
            RESULTAT=TEMP,
            NOM_CHAM='TEMP',
            TYPE_CHAM='NOEU_TEMP_R',
            OPERATION='EXTR'
        )

    else:
    
        STEP = DEFI_LIST_REEL(
            DEBUT=time,
            INTERVALLE=(_F(JUSQU_A=time+preciceDt, NOMBRE=1))
        )
        
        if participant["non-linear"]:
            TEMP = THER_NON_LINE(
                MODELE=MODEL,
                CHAM_MATER=MATS,
                EXCIT=LOADS,
                ETAT_INIT=ICOND,
                INCREMENT=_F(LIST_INST=STEP),
                PARM_THETA=1.0
            )
        else:
            TEMP = THER_LINEAIRE(
                MODELE=MODEL,
                CHAM_MATER=MATS,
                EXCIT=LOADS,
                ETAT_INIT=ICOND,
                INCREMENT=_F(LIST_INST=STEP),
                PARM_THETA=1.0
            )
        
        T = CREA_CHAMP(
            RESULTAT=TEMP,
            NOM_CHAM='TEMP',
            TYPE_CHAM='NOEU_TEMP_R',
            OPERATION='EXTR',
            NUME_ORDRE=1,
        )

    # ======================================================================================
    # Extract and write boundary values
    # ======================================================================================
    
    adapter.sendCouplingData(T, preciceDt)

    # ======================================================================================
    # Advance
    # ======================================================================================
        
    preciceDt = precice.advance(preciceDt)
    
    # ======================================================================================
    # Check convergence, read checkpoint if necessary
    # ======================================================================================
    
    if precice.isActionRequired(PyActionReadIterationCheckpoint()):
        precice.fulfilledAction(PyActionReadIterationCheckpoint())
    else:
        if time > 0:
            DETRUIRE(CONCEPT=_F(NOM=PRV_TEMP))
        PRV_TEMP = COPIER(CONCEPT=TEMP)
        
        if k % settings["simulation"]["output-frequency"] == 0:
               filename = "output-" + str(k) + ".rmed"
               DEFI_FICHIER(FICHIER=filename, UNITE=80)
               IMPR_RESU(FORMAT='MED', RESU=_F(RESULTAT=TEMP));
               call(["mv", filename, settings["base-path"] + "/" + participant["output-directory"]])
               DEFI_FICHIER(ACTION='LIBERER', UNITE=80)
               
        k = k + 1

        time = time + preciceDt

    # ======================================================================================
    # Destroy Aster objects
    # ======================================================================================
    
    DETRUIRE(CONCEPT=_F(NOM=TEMP))
    DETRUIRE(CONCEPT=_F(NOM=T))
    
    if not isSteadyState:
        DETRUIRE(CONCEPT=_F(NOM=STEP))

FIN()
